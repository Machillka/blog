[{"content":"开闭原则 对扩展开放，对修改关闭。也就是说，当需求变化或功能需要增加时，我们通过扩展已有的模块来实现，而不是修改已有的代码。这样可以在不影响原有功能的前提下，引入新特性，提升系统的可维护性和可扩展性。\n在封装层面上的策略，主要说明对一个类的拓展应当如何实现\n依赖倒置原则 看到的定义感觉比较复杂，简单来说 ——\n情景：我们（高层）需要使用一个类A（底层），那么，如果直接引用A，在未来如果需要应用类B的时候就需要修改我们自身，容易出问题。所以我们可以通过一个接口来访问我们需要的东西，然后让类A、B等实现这个接口，这样就不需要修改我们自身，只需要定义好底层就可以了。\n实例例子 —— 客户吃Food，原先只想到了客户吃饭，直接传递一个rice给客户\n1 2 3 4 5 6 7 class Sercice { public void Eating(Rice rice) { ... } } 如果客户想要吃面，就需要重载一个 Eating，或者修改 Eating 中的内容，非常麻烦，于是想到抽象出一个Food，客户只需要使用Food即可\n1 2 3 4 5 6 7 class Service { public void Eating(Food food) { ... } } 然后Food的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface Food { ... } public class Rice : Food { ... } public class Noodle : Food { ... } public class OtherFood : Food 这样可以在不修改客户代码逻辑的前提下，使其可以食用各种食物 ——\n==依赖倒置原则==：高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。\n高层次的模块不应该依赖于低层次的模块，两者都应该依赖与抽象接口 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 理解 引用獭獭的话 —— 开闭对标的是封装，依赖倒置对标的是多态，两个维度的代码组织上的策略\n或许，OCP 重点是一个类的拓展，DIP 是侧重对于不同的模块间的解耦？\n","date":"2025-07-15T17:07:19+08:00","permalink":"https://blog.machillka.me/p/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","title":"设计原则"},{"content":"工厂模式 制造汽车，划分成为了奔驰汽车厂、福特汽车厂等，每一个工厂都是继承工厂，只负责生产一个品牌的车子； 制造食物，划分成为了拉面店、炒饭店、火锅店等，每一家店都只生产对应的食物。\n","date":"2025-07-15T14:32:27+08:00","image":"https://blog.machillka.me/p/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/header_hu_fdfaa8854e0a45d4.jpg","permalink":"https://blog.machillka.me/p/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"工厂模式"},{"content":"关于抽象类（Abstract）和接口（Interface）在使用的时候的思考\n写在前面 抽象类和接口都定义了一系列的抽象成员，可以在继承的派生中重新实现。\n那么引出问题 ——\n为什么有了抽象还需要有接口 都是定义了部分抽象成员，二者有什么区别 使用场景 抽象理解 抽象相当于讲述了 “ 你是什么 ”，比如哺乳动物是动物；玩家是人；三角形是一个几何图形 ……\n当我们知道所有的动物的共同特征的时候，就可以封装成一个抽象的动物类，接着在其他的动物类别（比如爬行动物、哺乳动物等）继承动物抽象类，指明所有动物共有的默认行为或者属性之类。\n抽象类通过简单的继承，实现了多态，化简了重复代码、提升代码的逻辑性；\n⚠️ 只能单继承，可以有成员变量 接口理解 接口相当于讲述了 “ 你可以做什么 “，即鸟可以飞，飞机也可以飞，所以可以把飞作为它们可以干的事情封装成一个接口\n你可能是一个普通的GameObject，但是依旧可以响应鼠标点击事件，于是可以再继承一个鼠标点击事件的接口，然后实现当接受到鼠标点击事件的时候所需要做出的逻辑即可。\n接口类似于一种 “ 游戏规则 ”，继承了这个接口，必须实现这个接口里的东西。又由于可以继承多个接口，所以可以相当于 “ 拓展方法 ” 来使用。\n","date":"2025-07-14T16:30:54+08:00","image":"https://blog.machillka.me/p/%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%80%9D%E8%80%83/header_hu_c91e087200693558.jpg","permalink":"https://blog.machillka.me/p/%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%80%9D%E8%80%83/","title":"抽象和接口的思考"},{"content":"基础权限 修饰符 可见范围 备注 public 所有 对所有可见 private 当前类 只能在当前的类才内访问，派生类无法访问 protect 当前类和派生类 派生类可以访问（可以跨程序集） internal 当前程序集 也就是当前项目的所有代码都可以访问 继承与多态 abstract ”抽象“，也就是标记为未实现，需要在派生类当中做出实现，实现的时候使用 override 修饰符\nℹ️ 如果类内含有抽象成员，就必须用 abstract 修饰这个类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AnimalBase { // 所有 Animal 都有的 并且可以随时读写 public int Id { get; set; } // 所有 Animal 都有名字，但是需要自己去实现自己的名字是什么 public abstract string Name { get; } } public class Cat : AnimalBase { // 使用 override 表示重载 abstract 中定义的属性 public override string Name =\u0026gt; \u0026#34;Cat\u0026#34;; // 只有 Cat 才有捕捉老鼠的行为 所以定义为成员 public void CatchMouse() { Console.WriteLine(\u0026#34;This cat is catching a mouse\u0026#34;); } } virtual ”虚“，可以在基类中提供默认实现的 “abstact”，派生类可以选择是否重载 (override) 它 但是只能修饰 方法、属性、索引器、事件，==不可以修饰类== 含有虚成员的类可以不是抽象类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Person { public virtual string Name =\u0026gt; \u0026#34;Nobody\u0026#34;; } public class Tom : Person { public override string Name =\u0026gt; \u0026#34;Tom\u0026#34;; } public class Nobody : Person { public void LoudOutSadness() { // 输出就是 Person 的默认实现, 即 Nobody Console.WriteLine(Name); } } override 用于标记重载抽象成员或者虚成员\nsealed “密封”，标记此\n方法，无法再重载 类，无法再派生 如下 ![[Pasted image 20250706085912.png]] dog 是最后一层封装，我们无法对它进行派生（不然会出现Monster，害怕 适用于不希望暴露扩展点的核心类，比如工具类或安全敏感类。\nnew ”隐藏“，创建一个与基类同名但独立的成员，具体调用哪一个成员，看实例化对象的类型\n特性修饰符 static 无需实例化可以直接访问（dotnet 中 CLR 按需 在类型加载时分配静态字段内存，静态构造则在首次使用前执行）\nconst 编译时常量\nreadonly 运行时常量，仅能在声明或构造函数中赋值\npartial 拆分声明到多个文件内\n1 2 3 4 5 6 7 8 9 10 11 // File1.cs public partial class Person { public string Name { get; set; } } // File2.cs public partial class Person { public int Age { get; set; } } 此时 Person 拥有 Name 和 Age 两个属性\nextern 声明外部实现（针对方法）\n1 2 3 4 5 public class NativeMethods { [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern int MessageBox(IntPtr h, string t, string c, uint u); } unsafe 可以使用不安全的代码（比如指针操作）\n","date":"2025-07-05T23:49:48+08:00","image":"https://blog.machillka.me/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/header_hu_56f5da21599d79dc.jpg","permalink":"https://blog.machillka.me/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/","title":"面向对象的思考"},{"content":"对 Rust 的所有权的一些理解\n堆和栈 堆 通常不连续，受物理内存的限制，空间比较大，一般分配大型数据或者动态数据 离开作用域之后直接回收\n栈 通常连续，空间有限（溢栈错误常见），一般分配中小型数据。存储的所有数据都必须占用==已知==的==固定大小==的内存空间\nOwnership Rust 通过所有权系统来管理内存\nRust 中每一个值都被一个变量所拥有，该变量被称为值的所有者 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop) —— Rust Course Case 1 栈区 一般针对基本类型\n1 2 3 4 5 let x: i32 = 5; let y: i32 = x; println!(\u0026#34;x = {}, y = {}\u0026#34;, x, y); // 输出不一样的地址 println!(\u0026#34;*x = {:p}, *y = {:p}\u0026#34;, \u0026amp;x, \u0026amp;y); 直接在栈区复制, 相当于对该引用进行了拷贝, ( 从栈区开辟了一个新的内存存储 y ) 所以 x 对 5 的所有权不会消失 访问 x 不会有问题\nCase 2 堆区 一般对于需要动态分配的数据或者大型数据而言\n1 2 3 let s = String::from(\u0026#34;Hello Rust\u0026#34;); let s1 = s; println!(\u0026#34;s = {}\u0026#34;, s); // Error! ==错误代码==\n分析 ——\n\u0026ldquo;Hello Rust“ 在堆区开辟，s 拥有其所有权 s1 是对于 s 的拷贝，类似于浅拷贝，s1 现在指向 \u0026ldquo;Hello Rust\u0026rdquo;, 导致 s 没有指向一个明确的内存空间，于是被回收（drop）无法访问 再次访问 s 报错 Case 3 函数 传递所有权 1 2 3 4 5 6 fn take_ownership_int(s: i32) { // s 不会被回收，所有权还是给调用此函数的那个变量 } fn take_ownership_string(s: String) { // s 会被回收， } 对于传递基本类型来说，会标记 no drop 不回收，也就是在执行完函数之后所有权还是会还给传给这个函数的变量。 比如 ——\n1 2 let x: i32 = 11; take_ownership_int(x) 此时所有权还是 x 的\n但是对于复杂类型来说，把变量传递给此函数的时候，已经把所有权移交给函数了，而在函数执行完成之后，参数会被回收。比如 ——\n1 2 3 let s = String::from(\u0026#34;Hello rust\u0026#34;); take_ownership_string(s); println!(\u0026#34;{}\u0026#34;, s); ==错误代码==\n分析 ——\ns 拥有 \u0026ldquo;Hello rust\u0026rdquo; 的所有权 s 的所有权移交给了 take_ownership_string 函数 take_ownership_string 函数执行完成，并没有归还 s 的所有权给 s，而是回收（因为开辟在堆区） 导致 s 无法再被访问 也可以还回去\n1 2 3 4 fn giveback_ownership(s: String) -\u0026gt; String { println!(\u0026#34;{}\u0026#34;, s); s } 借用 ℹ️ 不移交变量的所有权，而是给出变量的引用 用于解决反复对于所有权移交的复杂，提出借用的概念。（有点类似 C 中的引用传递）\n1 2 3 fn borrow_test(s: \u0026amp;String) { // 可以读取 s 的数值, 并且不会影响传参的所有权 } 这里的 s 就是对传入参数的借用 （引用），但是是不可变引用 可以有如下用法\n1 2 3 let s = String::from(\u0026#34;Hello rust\u0026#34;); borrow_test(\u0026amp;s); println!(\u0026#34;{}\u0026#34;, s); 在 borrow_test 中只传递了 s 的不可变引用, 所以不影响 s 的所有权, s 依旧可以访问\n如果想要传入可变引用的话 ——\n1 2 3 fn mut_borrow_test(s: mut \u0026amp;String) { // 可以对 s 进行修改 } 此处不影响传参的所有权，但是可以在函数中修改变量\nℹ️ Note 不可变引用可以有多个 可变引用只能有一个 ","date":"2025-07-02T22:19:08+08:00","permalink":"https://blog.machillka.me/p/rust-ownership/","title":"Rust Ownership"},{"content":"写在前面 修改完之前做的 arona-sddm 主题之后，忽然想到来一个什庭之匣的 “ 沉浸式 ” 体验，于是发现 splash 主题的位置比较合适放一点东西，于是开始整活 ——\n主题搭建 准备工作 考据一下序章的内容，首先先得到普通的登录界面的图片。 接着使用 AE 把中间的图案拉下来然后做一个故障风的特效，用来配合下面的文字以及序章的感觉 本来打算文字也重新做的，但是嫌麻烦就未来可期吧 最后导出 gif，方便调用 （尝试过帧序列实现，感觉不如 gif 简单好用\n制作过程 原先之做了动图背景，但是发现有点单调，于是配合了 sddm 主题的样式，再添加了一个 “Welcome, Sensei”\n但是还是很单调 —— 加入打字机的效果 （用 Qt 实现）\n以后或许也做成故障风格的字样会比较合适一点，直接写上去的字体不是很舒服。\n","date":"2025-06-25T01:49:00+08:00","image":"https://blog.machillka.me/p/splash-theme/preview_hu_2dd091ef21bd2c37.png","permalink":"https://blog.machillka.me/p/splash-theme/","title":"Splash Theme"},{"content":"几何背景制作 Grid —— 对 shape 使用，生成网格背景\n","date":"2025-06-20T00:15:08+08:00","permalink":"https://blog.machillka.me/p/%E5%B8%B8%E7%94%A8%E7%89%B9%E6%95%88%E6%B1%87%E6%80%BB/","title":"常用特效汇总"},{"content":"综述 文本编辑器使用 Obsidian 云端存储 Github 比之前==加强的一点== —— 可以选择是否要上传到 Blog 上\n早年想到的方案是在 github 上跨仓库调用，但是这样无法实现\n实现 针对 Blog System 首先使用 Hugo 快速搭建静态 blog 的一个主框架（主要是对 Go 比较熟悉 接着快速加入 theme 等子模块 使用 Github Action 自动部署到 Pages 上\n针对 Obsidian 把普通笔记和博客文章的元数据封装成 Template Quick Add 先搭建基础模型 —— 创建两个 Choice 分别对应通过模板创建普通笔记和博客笔记 编写一个宏 —— 包含把当前激活的文件封装成 Hugo Pages 需要的形式 最后再次利用 Quick Add 调用脚本实现上传到 Github 上触发条件可以是手动或者保存时自动调用 编写 workflow 以调用 Github Action 自动部署 踩坑 Template 模板生成的时间与 Hugo 不对应，导致无法在 Hugo 上构建\nPages 没有添加 CNAME 解析，导致域名绑定失效\nQuick Add 非常恶心 没有重启 Obsidian 调用外部 JS 会提示空！\nJS 速通 JS 导致写的很烂\n调用 powershell 的时候 使用\n1 exec(powershell) 而不是\n1 exec(pwsh) powershell 默认路径是 Windows 下的垃圾东西，也没设置 Proxy，导致连接 Github 可能失败\n未来可期 封装成一个插件丢到社区里\n","date":"2025-06-20T00:00:42+08:00","permalink":"https://blog.machillka.me/p/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"笔记目录工作流"}]