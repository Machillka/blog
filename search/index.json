[{"content":"对 Rust 的所有权的一些理解\n堆和栈 堆 通常不连续，受物理内存的限制，空间比较大，一般分配大型数据或者动态数据 离开作用域之后直接回收\n栈 通常连续，空间有限（溢栈错误常见），一般分配中小型数据。存储的所有数据都必须占用==已知==的==固定大小==的内存空间\nOwnership Rust 通过所有权系统来管理内存\nRust 中每一个值都被一个变量所拥有，该变量被称为值的所有者 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop) —— Rust Course Case 1 栈区 一般针对基本类型\n1 2 3 4 5 let x: i32 = 5; let y: i32 = x; println!(\u0026#34;x = {}, y = {}\u0026#34;, x, y); // 输出不一样的地址 println!(\u0026#34;*x = {:p}, *y = {:p}\u0026#34;, \u0026amp;x, \u0026amp;y); 直接在栈区复制, 相当于对该引用进行了拷贝, ( 从栈区开辟了一个新的内存存储 y ) 所以 x 对 5 的所有权不会消失 访问 x 不会有问题\nCase 2 堆区 一般对于需要动态分配的数据或者大型数据而言\n1 2 3 let s = String::from(\u0026#34;Hello Rust\u0026#34;); let s1 = s; println!(\u0026#34;s = {}\u0026#34;, s); // Error! ==错误代码==\n分析 ——\n\u0026ldquo;Hello Rust“ 在堆区开辟，s 拥有其所有权 s1 是对于 s 的拷贝，类似于浅拷贝，s1 现在指向 \u0026ldquo;Hello Rust\u0026rdquo;, 导致 s 没有指向一个明确的内存空间，于是被回收（drop）无法访问 再次访问 s 报错 Case 3 函数 传递所有权 1 2 3 4 5 6 fn take_ownership_int(s: i32) { // s 不会被回收，所有权还是给调用此函数的那个变量 } fn take_ownership_string(s: String) { // s 会被回收， } 对于传递基本类型来说，会标记 no drop 不回收，也就是在执行完函数之后所有权还是会还给传给这个函数的变量。 比如 ——\n1 2 let x: i32 = 11; take_ownership_int(x) 此时所有权还是 x 的\n但是对于复杂类型来说，把变量传递给此函数的时候，已经把所有权移交给函数了，而在函数执行完成之后，参数会被回收。比如 ——\n1 2 3 let s = String::from(\u0026#34;Hello rust\u0026#34;); take_ownership_string(s); println!(\u0026#34;{}\u0026#34;, s); ==错误代码==\n分析 ——\ns 拥有 \u0026ldquo;Hello rust\u0026rdquo; 的所有权 s 的所有权移交给了 take_ownership_string 函数 take_ownership_string 函数执行完成，并没有归还 s 的所有权给 s，而是回收（因为开辟在堆区） 导致 s 无法再被访问 也可以还回去\n1 2 3 4 fn giveback_ownership(s: String) -\u0026gt; String { println!(\u0026#34;{}\u0026#34;, s); s } 借用 ℹ️ 不移交变量的所有权，而是给出变量的引用 用于解决反复对于所有权移交的复杂，提出借用的概念。（有点类似 C 中的引用传递）\n1 2 3 fn borrow_test(s: \u0026amp;String) { // 可以读取 s 的数值, 并且不会影响传参的所有权 } 这里的 s 就是对传入参数的借用 （引用），但是是不可变引用 可以有如下用法\n1 2 3 let s = String::from(\u0026#34;Hello rust\u0026#34;); borrow_test(\u0026amp;s); println!(\u0026#34;{}\u0026#34;, s); 在 borrow_test 中只传递了 s 的不可变引用, 所以不影响 s 的所有权, s 依旧可以访问\n如果想要传入可变引用的话 ——\n1 2 3 fn mut_borrow_test(s: mut \u0026amp;String) { // 可以对 s 进行修改 } 此处不影响传参的所有权，但是可以在函数中修改变量\nℹ️ Note 不可变引用可以有多个 可变引用只能有一个 ","date":"2025-07-02T22:19:08+08:00","permalink":"https://blog.machillka.me/p/rust-ownership/","title":"Rust Ownership"},{"content":"写在前面 修改完之前做的 arona-sddm 主题之后，忽然想到来一个什庭之匣的 “ 沉浸式 ” 体验，于是发现 splash 主题的位置比较合适放一点东西，于是开始整活 ——\n主题搭建 准备工作 考据一下序章的内容，首先先得到普通的登录界面的图片。 接着使用 AE 把中间的图案拉下来然后做一个故障风的特效，用来配合下面的文字以及序章的感觉 本来打算文字也重新做的，但是嫌麻烦就未来可期吧 最后导出 gif，方便调用 （尝试过帧序列实现，感觉不如 gif 简单好用\n制作过程 原先之做了动图背景，但是发现有点单调，于是配合了 sddm 主题的样式，再添加了一个 “Welcome, Sensei”\n但是还是很单调 —— 加入打字机的效果 （用 Qt 实现）\n以后或许也做成故障风格的字样会比较合适一点，直接写上去的字体不是很舒服。\n","date":"2025-06-25T01:49:00+08:00","image":"https://blog.machillka.me/p/splash-theme/preview_hu_2dd091ef21bd2c37.png","permalink":"https://blog.machillka.me/p/splash-theme/","title":"Splash Theme"},{"content":"几何背景制作 Grid —— 对 shape 使用，生成网格背景\n","date":"2025-06-20T00:15:08+08:00","permalink":"https://blog.machillka.me/p/%E5%B8%B8%E7%94%A8%E7%89%B9%E6%95%88%E6%B1%87%E6%80%BB/","title":"常用特效汇总"},{"content":"综述 文本编辑器使用 Obsidian 云端存储 Github 比之前==加强的一点== —— 可以选择是否要上传到 Blog 上\n早年想到的方案是在 github 上跨仓库调用，但是这样无法实现\n实现 针对 Blog System 首先使用 Hugo 快速搭建静态 blog 的一个主框架（主要是对 Go 比较熟悉 接着快速加入 theme 等子模块 使用 Github Action 自动部署到 Pages 上\n针对 Obsidian 把普通笔记和博客文章的元数据封装成 Template Quick Add 先搭建基础模型 —— 创建两个 Choice 分别对应通过模板创建普通笔记和博客笔记 编写一个宏 —— 包含把当前激活的文件封装成 Hugo Pages 需要的形式 最后再次利用 Quick Add 调用脚本实现上传到 Github 上触发条件可以是手动或者保存时自动调用 编写 workflow 以调用 Github Action 自动部署 踩坑 Template 模板生成的时间与 Hugo 不对应，导致无法在 Hugo 上构建\nPages 没有添加 CNAME 解析，导致域名绑定失效\nQuick Add 非常恶心 没有重启 Obsidian 调用外部 JS 会提示空！\nJS 速通 JS 导致写的很烂\n调用 powershell 的时候 使用\n1 exec(powershell) 而不是\n1 exec(pwsh) powershell 默认路径是 Windows 下的垃圾东西，也没设置 Proxy，导致连接 Github 可能失败\n未来可期 封装成一个插件丢到社区里\n","date":"2025-06-20T00:00:42+08:00","permalink":"https://blog.machillka.me/p/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"笔记目录工作流"}]